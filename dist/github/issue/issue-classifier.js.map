{
  "version": 3,
  "sources": ["../../../src/github/issue/issue-classifier.ts", "../../../src/github/pull-request/pr-analyzer.ts"],
  "sourcesContent": ["import {\n  Octokit,\n  RepoContext,\n  Issue,\n  IssueClassification,\n} from \"../type/types\";\nimport {\n  getLinkedPRs,\n  countMergedPRs,\n  hasIssueReferenceInPRs,\n} from \"../pull-request/pr-analyzer\";\n\n/**\n * Options for issue classification\n */\ninterface ClassifierOptions {\n  minLinkedPRs: number;\n  minMergedPRs: number;\n}\n\n/**\n * Classify issues based on PR status\n * @param octokit - GitHub API client\n * @param context - Repository context\n * @param issues - Issues to classify\n * @param options - Classification options\n * @returns Classified issues (completed, inProgress, pending)\n */\nexport async function classifyIssues(\n  octokit: Octokit,\n  context: RepoContext,\n  issues: any[],\n  options: ClassifierOptions\n): Promise<IssueClassification> {\n  const completed: Issue[] = [];\n  const inProgress: Issue[] = [];\n  const pending: Issue[] = [];\n\n  for (const issue of issues) {\n    // Get linked PRs from timeline\n    const linkedPRs = await getLinkedPRs(octokit, context, issue.number);\n\n    // Check if minimum linked PRs requirement is met\n    if (linkedPRs.length < options.minLinkedPRs) {\n      pending.push(issue);\n      continue;\n    }\n\n    // Count merged PRs\n    const mergedCount = await countMergedPRs(octokit, context, linkedPRs);\n\n    // Check if minimum merged PRs requirement is met\n    if (mergedCount < options.minMergedPRs) {\n      inProgress.push(issue);\n      continue;\n    }\n\n    // Check if any PR body references this issue\n    const hasReference = await hasIssueReferenceInPRs(\n      octokit,\n      context,\n      issue.number,\n      linkedPRs\n    );\n\n    if (hasReference) {\n      completed.push(issue);\n    } else {\n      inProgress.push(issue);\n    }\n  }\n\n  // Sort by issue number\n  completed.sort((a, b) => b.number - a.number);\n  inProgress.sort((a, b) => b.number - a.number);\n  pending.sort((a, b) => b.number - a.number);\n\n  return { completed, inProgress, pending };\n}\n", "import { Octokit, RepoContext } from \"../type/types\";\n\n/**\n * Get linked PRs from issue timeline\n *\n * Retrieves all pull requests that are cross-referenced in the issue timeline.\n * This includes PRs that mention the issue in their body, title, or comments.\n */\nexport async function getLinkedPRs(\n  octokit: Octokit,\n  context: RepoContext,\n  issueNumber: number\n): Promise<any[]> {\n  const { data: timeline } = await octokit.rest.issues.listEventsForTimeline({\n    owner: context.owner,\n    repo: context.repo,\n    issue_number: issueNumber,\n  });\n\n  // Filter for cross-referenced events that are pull requests (not regular issues)\n  return timeline.filter(\n    (event: any) =>\n      event.event === \"cross-referenced\" &&\n      event.source &&\n      event.source.type === \"issue\" &&\n      event.source.issue.pull_request\n  );\n}\n\n/**\n * Count merged PRs from linked PRs\n *\n * Counts how many of the linked PRs have actually been merged into the repository.\n * This is used to determine if an issue has sufficient merged PRs to be considered\n * \"in progress\" or potentially \"completed\".\n */\nexport async function countMergedPRs(\n  octokit: Octokit,\n  context: RepoContext,\n  linkedPRs: any[]\n): Promise<number> {\n  let mergedCount = 0;\n\n  for (const linkedPR of linkedPRs) {\n    const prNumber = linkedPR.source.issue.number;\n\n    const { data: prDetails } = await octokit.rest.pulls.get({\n      owner: context.owner,\n      repo: context.repo,\n      pull_number: prNumber,\n    });\n\n    if (prDetails.merged) {\n      mergedCount++;\n    }\n  }\n\n  return mergedCount;\n}\n\n/**\n * Check if any PR body references the issue\n *\n * This function verifies that merged PRs actually intended to resolve the issue\n * by checking if the PR body contains an explicit reference to the issue number (e.g., \"fixes #5\", \"closes #10\").\n *\n * Why this is needed:\n * - A PR might be linked to an issue via timeline cross-reference without actually fixing it\n * - Multiple PRs might be merged, but none of them actually address the specific issue\n * - This ensures completed issues were intentionally resolved, not just incidentally linked\n *\n * Example:\n * - Issue #5: \"Fix login bug\"\n * - PR #10: \"Refactor auth\" (merged, but no #5 reference) \u2192 Not a fix\n * - PR #11: \"Fix login bug closes #5\" (merged, with #5 reference) \u2192 Actual fix\n */\nexport async function hasIssueReferenceInPRs(\n  octokit: Octokit,\n  context: RepoContext,\n  issueNumber: number,\n  linkedPRs: any[]\n): Promise<boolean> {\n  for (const linkedPR of linkedPRs) {\n    const prNumber = linkedPR.source.issue.number;\n\n    const { data: prDetails } = await octokit.rest.pulls.get({\n      owner: context.owner,\n      repo: context.repo,\n      pull_number: prNumber,\n    });\n\n    // Use word boundary (\\b) to prevent partial matches (e.g., #50 should not match #5)\n    const issuePattern = new RegExp(`#${issueNumber}\\\\b`, \"i\");\n    if (prDetails.body && issuePattern.test(prDetails.body)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACQA,eAAsB,aACpB,SACA,SACA,aACgB;AAChB,QAAM,EAAE,MAAM,SAAS,IAAI,MAAM,QAAQ,KAAK,OAAO,sBAAsB;AAAA,IACzE,OAAO,QAAQ;AAAA,IACf,MAAM,QAAQ;AAAA,IACd,cAAc;AAAA,EAChB,CAAC;AAGD,SAAO,SAAS;AAAA,IACd,CAAC,UACC,MAAM,UAAU,sBAChB,MAAM,UACN,MAAM,OAAO,SAAS,WACtB,MAAM,OAAO,MAAM;AAAA,EACvB;AACF;AASA,eAAsB,eACpB,SACA,SACA,WACiB;AACjB,MAAI,cAAc;AAElB,aAAW,YAAY,WAAW;AAChC,UAAM,WAAW,SAAS,OAAO,MAAM;AAEvC,UAAM,EAAE,MAAM,UAAU,IAAI,MAAM,QAAQ,KAAK,MAAM,IAAI;AAAA,MACvD,OAAO,QAAQ;AAAA,MACf,MAAM,QAAQ;AAAA,MACd,aAAa;AAAA,IACf,CAAC;AAED,QAAI,UAAU,QAAQ;AACpB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAkBA,eAAsB,uBACpB,SACA,SACA,aACA,WACkB;AAClB,aAAW,YAAY,WAAW;AAChC,UAAM,WAAW,SAAS,OAAO,MAAM;AAEvC,UAAM,EAAE,MAAM,UAAU,IAAI,MAAM,QAAQ,KAAK,MAAM,IAAI;AAAA,MACvD,OAAO,QAAQ;AAAA,MACf,MAAM,QAAQ;AAAA,MACd,aAAa;AAAA,IACf,CAAC;AAGD,UAAM,eAAe,IAAI,OAAO,IAAI,WAAW,OAAO,GAAG;AACzD,QAAI,UAAU,QAAQ,aAAa,KAAK,UAAU,IAAI,GAAG;AACvD,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;;;ADvEA,eAAsB,eACpB,SACA,SACA,QACA,SAC8B;AAC9B,QAAM,YAAqB,CAAC;AAC5B,QAAM,aAAsB,CAAC;AAC7B,QAAM,UAAmB,CAAC;AAE1B,aAAW,SAAS,QAAQ;AAE1B,UAAM,YAAY,MAAM,aAAa,SAAS,SAAS,MAAM,MAAM;AAGnE,QAAI,UAAU,SAAS,QAAQ,cAAc;AAC3C,cAAQ,KAAK,KAAK;AAClB;AAAA,IACF;AAGA,UAAM,cAAc,MAAM,eAAe,SAAS,SAAS,SAAS;AAGpE,QAAI,cAAc,QAAQ,cAAc;AACtC,iBAAW,KAAK,KAAK;AACrB;AAAA,IACF;AAGA,UAAM,eAAe,MAAM;AAAA,MACzB;AAAA,MACA;AAAA,MACA,MAAM;AAAA,MACN;AAAA,IACF;AAEA,QAAI,cAAc;AAChB,gBAAU,KAAK,KAAK;AAAA,IACtB,OAAO;AACL,iBAAW,KAAK,KAAK;AAAA,IACvB;AAAA,EACF;AAGA,YAAU,KAAK,CAAC,GAAG,MAAM,EAAE,SAAS,EAAE,MAAM;AAC5C,aAAW,KAAK,CAAC,GAAG,MAAM,EAAE,SAAS,EAAE,MAAM;AAC7C,UAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,SAAS,EAAE,MAAM;AAE1C,SAAO,EAAE,WAAW,YAAY,QAAQ;AAC1C;",
  "names": []
}
